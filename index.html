<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Brick Breaker Game</title>
  <style>
    body {
      text-align: center;
      background-color: #1e1e1e;
      color: white;
      font-family: Arial, sans-serif;
    }
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    canvas {
      background: #222;
      border: 3px solid white;
    }
    #controls {
      margin-top: 10px;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      border: none;
      cursor: pointer;
      font-size: 16px;
      border-radius: 5px;
      transition: 0.3s;
    }
    #startButton {
      background-color: green;
      color: white;
    }
    #startButton:hover {
      background-color: darkgreen;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</head>
<body>
  <div id="gameContainer">
    <canvas id="myCanvas" width="600" height="400"></canvas>
    <div id="controls">
      <button id="startButton">Start Game</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    let gameStarted = false;
    let ballRadius = 10;
    let paddleHeight = 10;
    let paddleWidth = 100;
    let defaultPaddleWidth = paddleWidth;
    let paddleX = (canvas.width - paddleWidth) / 2;
    let expanded = false;

    let rightPressed = false;
    let leftPressed = false;

    let brickRowCount = 4;
    let brickColumnCount = 7;
    let brickWidth = 70;
    let brickHeight = 20;
    let brickPadding = 10;
    let brickOffsetTop = 50;
    let brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding) - brickPadding)) / 2;

    let score = 0;
    let bricks = [];
    let particles = [];
    let multiBallUsed = false;

    let balls = [{
      x: canvas.width / 2,
      y: canvas.height - 30,
      dx: 3,
      dy: -3,
      radius: ballRadius,
      color: "#0095DD"
    }];

    const getRandomColor = () => "#" + Math.floor(Math.random() * 16777215).toString(16);

    // Assign special bricks (only one of each)
    const getUniqueBrick = (exclude = []) => {
      let unique;
      do {
        unique = {
          column: Math.floor(Math.random() * brickColumnCount),
          row: Math.floor(Math.random() * brickRowCount)
        };
      } while (exclude.some(e => e.column === unique.column && e.row === unique.row));
      return unique;
    };

    const explosiveBrick = getUniqueBrick();
    const blueBrick = getUniqueBrick([explosiveBrick]);
    const greenBrick = getUniqueBrick([explosiveBrick, blueBrick]);

    // Initialize bricks
    for (let c = 0; c < brickColumnCount; c++) {
      bricks[c] = [];
      for (let r = 0; r < brickRowCount; r++) {
        const isExplosive = (c === explosiveBrick.column && r === explosiveBrick.row);
        const isBlue = (c === blueBrick.column && r === blueBrick.row);
        const isGreen = (c === greenBrick.column && r === greenBrick.row);

        bricks[c][r] = {
          x: c * (brickWidth + brickPadding) + brickOffsetLeft,
          y: r * (brickHeight + brickPadding) + brickOffsetTop,
          status: 1,
          color: isExplosive ? "red" : isBlue ? "blue" : isGreen ? "green" : getRandomColor(),
          isExplosive,
          isBlue,
          isMulti: isGreen
        };
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 3 + 2;
        this.speedX = (Math.random() - 0.5) * 3;
        this.speedY = (Math.random() - 1) * 3;
        this.color = color;
        this.lifespan = 40;
      }
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.lifespan -= 1;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    function createParticles(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push(new Particle(x + brickWidth / 2, y + brickHeight / 2, color));
      }
    }

    function createPaddleParticles(x, y, color) {
      for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    function drawParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].lifespan <= 0) particles.splice(i, 1);
      }
    }

    function drawBalls() {
      balls.forEach(ball => {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.closePath();
      });
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, b.y, brickWidth, brickHeight);
          }
        }
      }
    }

    function expandPaddle() {
      if (!expanded) {
        paddleWidth *= 1.5;
        expanded = true;
        setTimeout(() => {
          paddleWidth = defaultPaddleWidth;
          expanded = false;
        }, 5000);
      }
    }

    function spawnExtraBalls(baseBall) {
      if (multiBallUsed) return;
      multiBallUsed = true;
      for (let i = 0; i < 2; i++) {
        balls.push({
          x: baseBall.x,
          y: baseBall.y,
          dx: (Math.random() - 0.5) * 6,
          dy: -Math.random() * 3 - 2,
          radius: ballRadius,
          color: baseBall.color
        });
      }
    }

    function collisionDetection() {
      balls.forEach(ball => {
        for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
            const b = bricks[c][r];
            if (b.status === 1) {
              if (
                ball.x > b.x &&
                ball.x < b.x + brickWidth &&
                ball.y > b.y &&
                ball.y < b.y + brickHeight
              ) {
                ball.dy = -ball.dy;
                ball.color = b.color;
                b.status = 0;
                score++;
                createParticles(b.x, b.y, b.color);

                if (b.isExplosive) destroyNearbyBricks(c, r);
                if (b.isBlue) expandPaddle();
                if (b.isMulti) spawnExtraBalls(ball);

                checkWin();
              }
            }
          }
        }

        // Paddle collision
        if (
          ball.x > paddleX &&
          ball.x < paddleX + paddleWidth &&
          ball.y + ball.dy > canvas.height - ball.radius
        ) {
          if (ball.y + ball.dy < canvas.height - paddleHeight) {
            ball.dy = -ball.dy;
            createPaddleParticles(ball.x, ball.y, "#0095DD");
          }
        }
      });
    }

    function destroyNearbyBricks(col, row) {
      for (let dc = -1; dc <= 1; dc++) {
        for (let dr = -1; dr <= 1; dr++) {
          let nc = col + dc;
          let nr = row + dr;
          if (nc >= 0 && nc < brickColumnCount && nr >= 0 && nr < brickRowCount) {
            if (bricks[nc][nr].status === 1) {
              bricks[nc][nr].status = 0;
              createParticles(bricks[nc][nr].x, bricks[nc][nr].y, bricks[nc][nr].color);
            }
          }
        }
      }
    }

    function checkWin() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) return;
        }
      }

      gameStarted = false;
      Swal.fire({
        title: "Super!",
        text: "Zmagal si",
        icon: "success",
        confirmButtonText: "Igraj ponovno"
      }).then(() => document.location.reload());
    }

    function gameOver() {
      gameStarted = false;
      Swal.fire({
        title: "Napaka!",
        text: "Poskusi spet!",
        icon: "error",
        confirmButtonText: "Ponovi"
      }).then(() => document.location.reload());
    }

    function draw() {
      if (!gameStarted) return;

      ctx.fillStyle = "rgba(34, 34, 34, 0.4)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawBricks();
      drawParticles();
      drawBalls();
      drawPaddle();
      collisionDetection();

      balls.forEach(ball => {
        if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius)
          ball.dx = -ball.dx;
        if (ball.y + ball.dy < ball.radius) ball.dy = -ball.dy;
        else if (ball.y + ball.dy > canvas.height - ball.radius) {
          if (ball.x > paddleX && ball.x < paddleX + paddleWidth) {
            ball.dy = -ball.dy;
            createPaddleParticles(ball.x, canvas.height - paddleHeight);
          } else {
            balls = balls.filter(b => b !== ball);
            if (balls.length === 0) gameOver();
          }
        }

        ball.x += ball.dx;
        ball.y += ball.dy;
      });

      if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 7;
      if (leftPressed && paddleX > 0) paddleX -= 7;

      requestAnimationFrame(draw);
    }

    document.getElementById("startButton").addEventListener("click", () => {
      gameStarted = true;
      draw();
    });

    document.addEventListener("keydown", function (e) {
      if (e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "ArrowLeft") leftPressed = true;
    });

    document.addEventListener("keyup", function (e) {
      if (e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "ArrowLeft") leftPressed = false;
    });
  </script>
</body>
</html>
